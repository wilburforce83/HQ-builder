"use strict";

const fs = require("fs");
const path = require("path");

const rootDir = path.join(__dirname, "..");
const outputPath = path.join(rootDir, "src", "generated", "embeddedAssets.ts");

function toPosixPath(filePath) {
  return filePath.split(path.sep).join("/");
}

function readDirFilesRecursive(dirPath) {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    if (entry.name.startsWith(".")) continue;
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      files.push(...readDirFilesRecursive(fullPath));
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }
  return files;
}

function mimeForExtension(ext) {
  switch (ext.toLowerCase()) {
    case ".png":
      return "image/png";
    case ".jpg":
    case ".jpeg":
      return "image/jpeg";
    case ".webp":
      return "image/webp";
    case ".ttf":
      return "font/ttf";
    case ".otf":
      return "font/otf";
    case ".woff":
      return "font/woff";
    case ".woff2":
      return "font/woff2";
    default:
      return "application/octet-stream";
  }
}

function fileNameKey(filePath) {
  return path.basename(filePath);
}

function encodeFileToDataUrl(filePath) {
  const ext = path.extname(filePath);
  const mime = mimeForExtension(ext);
  const buffer = fs.readFileSync(filePath);
  const base64 = buffer.toString("base64");
  return `data:${mime};base64,${base64}`;
}

function buildEmbeddedFontsCss(embeddedFontsByFileName) {
  const carter = [
    { file: "Carter Sans W01 Regular.ttf", weight: 400 },
    { file: "Carter Sans W01 Medium.ttf", weight: 550 },
    { file: "Carter Sans W01 Bold.ttf", weight: 700 },
  ];

  const heroQuest = [{ file: "HeroQuest.ttf", weight: 400 }];

  const rules = [];

  for (const { file, weight } of carter) {
    const dataUrl = embeddedFontsByFileName[file];
    if (!dataUrl) {
      throw new Error(`[generate-embedded-assets] Missing expected font: ${file}`);
    }
    rules.push(`
@font-face {
  font-family: "Carter Sans W01";
  src: url("${dataUrl}") format("truetype");
  font-style: normal;
  font-weight: ${weight};
  font-display: swap;
}`.trim());
  }

  for (const { file, weight } of heroQuest) {
    const dataUrl = embeddedFontsByFileName[file];
    if (!dataUrl) {
      throw new Error(`[generate-embedded-assets] Missing expected font: ${file}`);
    }
    rules.push(`
@font-face {
  font-family: "HeroQuest";
  src: url("${dataUrl}") format("truetype");
  font-style: normal;
  font-weight: ${weight};
  font-display: swap;
}`.trim());
  }

  return rules.join("\n\n");
}

function main() {
  const imagesDirs = [
    path.join(rootDir, "src", "assets", "card-backgrounds"),
    path.join(rootDir, "src", "assets", "card-parts"),
  ];
  const fontsDir = path.join(rootDir, "public", "fonts");

  const imageFiles = imagesDirs.flatMap((dir) => readDirFilesRecursive(dir)).filter((file) => {
    const ext = path.extname(file).toLowerCase();
    return ext === ".png" || ext === ".jpg" || ext === ".jpeg" || ext === ".webp";
  });

  const fontFiles = readDirFilesRecursive(fontsDir).filter((file) => {
    const ext = path.extname(file).toLowerCase();
    return ext === ".ttf" || ext === ".otf" || ext === ".woff" || ext === ".woff2";
  });

  const embeddedImagesByFileName = Object.fromEntries(
    imageFiles
      .sort()
      .map((filePath) => [fileNameKey(filePath), encodeFileToDataUrl(filePath)]),
  );

  const embeddedFontsByFileName = Object.fromEntries(
    fontFiles
      .sort()
      .map((filePath) => [fileNameKey(filePath), encodeFileToDataUrl(filePath)]),
  );

  const embeddedFontFaceCss = buildEmbeddedFontsCss(embeddedFontsByFileName);

  const relImages = imageFiles.map((f) => toPosixPath(path.relative(rootDir, f)));
  const relFonts = fontFiles.map((f) => toPosixPath(path.relative(rootDir, f)));

  const banner = `// This file is auto-generated by scripts/generate-embedded-assets.cjs.\n// Do not edit by hand.\n`;

  const contents = `${banner}
export const embeddedImagesByFileName: Record<string, string> = ${JSON.stringify(
    embeddedImagesByFileName,
  )} as const;

export const embeddedFontsByFileName: Record<string, string> = ${JSON.stringify(
    embeddedFontsByFileName,
  )} as const;

export const embeddedFontFaceCss: string = ${JSON.stringify(embeddedFontFaceCss)} as const;

export const embeddedManifest = {
  images: ${JSON.stringify(relImages)} as const,
  fonts: ${JSON.stringify(relFonts)} as const,
} as const;
`;

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, contents, "utf8");
  console.log("[generate-embedded-assets] Wrote", path.relative(rootDir, outputPath));
  console.log("[generate-embedded-assets] Images:", imageFiles.length, "Fonts:", fontFiles.length);
}

main();

